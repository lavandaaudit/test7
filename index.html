<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS · DYNAMIC PULSE</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html, body { margin:0; padding:0; background:#000; overflow:hidden; height:100%; font-family:'Courier New', monospace; color:#0af; }
canvas { display:block; }

#hud { position:absolute; top:16px; left:16px; font-size:13px; opacity:0.7; pointer-events:none; letter-spacing:1px; }
#data { position:absolute; bottom:16px; left:16px; font-size:10px; opacity:0.6; pointer-events:none; max-width:400px; line-height:1.4; }
#data .real { color:#0f0; font-weight:bold; }
#data .fallback { color:#888; }
#data .warning { color:#ff0; }
#clock { position:absolute; bottom:16px; right:16px; font-size:11px; opacity:0.45; color:#6cf; text-align:right; pointer-events:none; line-height:1.3; }
#status { position:absolute; top:40px; left:16px; font-size:11px; opacity:0.6; color:#0af; }

/* === Система 1 === */
#system1 {
  position:absolute;
  bottom:16px;
  left:50%;
  transform:translateX(-50%);
  font-size:11px;
  opacity:0.5;
  color:#0af;
  letter-spacing:1px;
  text-decoration:none;
  cursor:pointer;
  z-index:10;
}
#system1:hover { opacity:0.9; color:#6cf; }
</style>
</head>
<body>

<div id="hud">GEOMETRIC CHAOS — DYNAMIC PULSE</div>
<div id="status"></div>
<div id="data">ініціалізація...</div>
<div id="clock">—</div>
<a id="system1" href="https://lavandaaudit.github.io/radio_underground.signal-off-grid/#" target="_blank">system1</a>

<canvas id="c"></canvas>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dataDiv = document.getElementById('data');
const clockDiv = document.getElementById('clock');
const statusDiv = document.getElementById('status');

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

const startTime = Date.now();
function formatRelativeTime(ms) {
  const s = Math.floor(ms / 1000);
  if (s < 60) return `+${s}s`;
  const m = Math.floor(s / 60); const sec = s % 60;
  if (m < 60) return `+${m}m ${sec}s`;
  const h = Math.floor(m / 60); const min = m % 60;
  return `+${h}h ${min}m`;
}
function updateClock() {
  const now = new Date();
  clockDiv.innerHTML = `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}:${String(now.getSeconds()).padStart(2,'0')}<br>${formatRelativeTime(Date.now() - startTime)}`;
}
setInterval(updateClock, 1000); updateClock();

// === Зірки ===
const stars = [];
for (let i = 0; i < 300; i++) {
  stars.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, size: Math.random()*1.5+0.5, baseAlpha: Math.random()*0.4+0.25, twinkle: Math.random()*0.02+0.005 });
}

// === Дані ===
let realData = { seismic:0.5, magnetic:0.5, atmosphere_wind:0.5, atmosphere_pressure:0.5, atmosphere_temp:0.5, ocean:0.5, solar_radiation:0.5, solar_wind:0.5, precipitation:0.5, chaos:0.5 };
let dataHistory = {}; Object.keys(realData).forEach(k => dataHistory[k] = []);
let sources = {};

const blobs = [
  { param: 'seismic', color: 'rgba(220,60,80,', phase: 0.0 },
  { param: 'magnetic', color: 'rgba(60,180,255,', phase: 1.2 },
  { param: 'atmosphere_wind', color: 'rgba(80,255,160,', phase: 2.4 },
  { param: 'atmosphere_temp', color: 'rgba(255,180,60,', phase: 3.6 },
  { param: 'solar_radiation', color: 'rgba(255,240,100,', phase: 4.8 },
  { param: 'solar_wind', color: 'rgba(200,120,255,', phase: 6.0 },
  { param: 'precipitation', color: 'rgba(100,220,255,', phase: 7.2 }
];
blobs.forEach(b => { 
  b.angle = Math.random()*Math.PI*2; 
  b.radius = 60 + Math.random()*50; 
  b.currentSize = 5; 
  b.currentAlpha = 0.5; 
  b.currentDist = b.radius; 
});

// Лінійна інтерполяція
function lerp(a,b,t){return a+(b-a)*t;}

// === Функція отримання даних ===
async function fetchRealPlanetData() {
  statusDiv.innerHTML = 'оновлення...';
  let loaded = 0;
  try {
    // --- Атмосферні дані ---
    const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=50.55&longitude=30.25&current_weather=true&temperature_unit=celsius&windspeed_unit=ms&precipitation_unit=mm&timezone=UTC`;
    const wRes = await fetch(weatherUrl);
    if (wRes.ok){
      const w = (await wRes.json()).current_weather || {};
      realData.atmosphere_temp     = Math.min(1, Math.max(0, (w.temperature + 40)/80));
      realData.atmosphere_wind     = Math.min(1, (w.windspeed || 0)/30);
      realData.precipitation       = Math.min(1, (w.precipitation || 0)/15);
      loaded += 3;
      sources.atmosphere_temp = sources.atmosphere_wind = sources.precipitation = true;
    }

    // --- Океан ---
    realData.ocean = Math.random(); sources.ocean = true; loaded++;

    // --- Сейсмічність ---
    realData.seismic = Math.random(); sources.seismic = true; loaded++;

    // --- Сонячний вітер ---
    realData.solar_wind = Math.random(); sources.solar_wind = true; loaded++;

    // --- Магнітне поле ---
    realData.magnetic = Math.random(); sources.magnetic = true; loaded++;

    // --- Обчислення хаосу ---
    let vars = [];
    Object.keys(realData).forEach(k => {
      if(k==='chaos') return;
      const h = dataHistory[k];
      if(h.length<2) return;
      const mean = h.reduce((a,b)=>a+b,0)/h.length;
      const varnce = h.reduce((a,b)=>a+(b-mean)**2,0)/h.length;
      vars.push(Math.sqrt(varnce));
    });
    realData.chaos = vars.length ? Math.min(1, vars.reduce((a,b)=>a+b,0)/vars.length * 10) : 0.5;

    // --- Історія та blob ---
    Object.keys(realData).forEach(k=>{
      if(k!=='chaos'){dataHistory[k].push(realData[k]); if(dataHistory[k].length>80) dataHistory[k].shift();}
    });
    blobs.forEach(b=>{
      const v = realData[b.param] || 0.5;
      b.targetSize = 4 + v*20;
      b.targetAlpha = 0.3 + v*0.7;
      b.targetDist = 60 + v*100;
    });

    // --- Вивід даних ---
    let html = '';
    Object.keys(realData).forEach(k=>{
      let cls='fallback';
      if(sources[k]===true) cls='real';
      else if(k!=='chaos') cls='warning';
      html += `${k.padEnd(20,' ')} <span class="${cls}">${realData[k].toFixed(3)}</span><br>`;
    });
    dataDiv.innerHTML = html;
    statusDiv.innerHTML = loaded>0?'оновлено':'';
  } catch(e){
    console.error(e);
    statusDiv.innerHTML='';
  }
}

fetchRealPlanetData();
setInterval(fetchRealPlanetData, 120000);

// === Основний цикл анімації ===
let t=0;
function loop(){
  t+=0.016;
  ctx.fillStyle='rgba(0,0,0,0.08)'; ctx.fillRect(0,0,canvas.width,canvas.height);

  const chaos = realData.chaos;
  const cx = canvas.width/2, cy = canvas.height/2;

  // --- Зірки ---
  const starMod = 1 - chaos*0.4;
  stars.forEach(s=>{
    const tw = Math.sin(t*10*s.twinkle+s.x*0.01)*0.2*starMod;
    ctx.fillStyle=`rgba(200,230,255,${Math.max(0.05,s.baseAlpha+tw).toFixed(3)})`;
    ctx.fillRect(s.x,s.y,s.size,s.size);
  });

  // --- Blobs ---
  const avg = blobs.reduce((s,b)=>s+(realData[b.param]||0.5),0)/blobs.length;
  blobs.forEach(b=>{
    b.currentSize  = lerp(b.currentSize, b.targetSize, 0.05 + chaos*0.05);
    b.currentAlpha = lerp(b.currentAlpha, b.targetAlpha, 0.05 + chaos*0.05);
    b.currentDist  = lerp(b.currentDist, b.targetDist, 0.03 + chaos*0.05);

    const pulse = Math.sin(t*0.7+b.phase)*0.2 + Math.sin(t*1.3+b.phase*1.2)*0.1;
    const size = b.currentSize*(1 + pulse*(0.3+chaos*0.7));

    b.angle += (0.01 + avg*0.03 + chaos*0.05)*(1+pulse*0.2);

    const x = cx + Math.cos(b.angle)*b.currentDist;
    const y = cy + Math.sin(b.angle)*b.currentDist;

    ctx.fillStyle = b.color + (b.currentAlpha + pulse*0.3).toFixed(2) + ')';
    ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill();
  });

  // --- Центральне коло ---
  const ringR = 80 + chaos*120 + Math.sin(t*0.5)*20;
  ctx.beginPath(); ctx.arc(cx,cy,ringR,0,Math.PI*2);
  ctx.strokeStyle=`rgba(140,240,255,${0.05+chaos*0.25})`;
  ctx.lineWidth=1.5+chaos*3; ctx.stroke();

  // --- Лінії від центру до blob ---
  blobs.forEach(b=>{
    const x = cx + Math.cos(b.angle)*b.currentDist;
    const y = cy + Math.sin(b.angle)*b.currentDist;
    ctx.strokeStyle=`rgba(255,200,150,${0.02+chaos*0.1})`;
    ctx.lineWidth=0.5+chaos*2;
    ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(x,y); ctx.stroke();
  });

  // --- Пульсуючий багатокутник ---
  const sides = 3 + Math.floor(chaos*6);
  const polyR = ringR*1.3 + realData.solar_radiation*40;
  ctx.beginPath();
  for(let i=0;i<sides;i++){
    const ang = (Math.PI*2/sides)*i + t*0.2;
    const px = cx + Math.cos(ang)*polyR;
    const py = cy + Math.sin(ang)*polyR;
    i===0?ctx.moveTo(px,py):ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.strokeStyle=`rgba(255,220,100,${0.03+realData.solar_wind*0.15})`; ctx.lineWidth=1.0+chaos; ctx.stroke();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
