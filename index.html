<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>GEOMETRIC CHAOS · VECTOR FIELD</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html, body {
  margin:0; padding:0;
  background:#05070a;
  overflow:hidden;
  height:100%;
  font-family:'Courier New', monospace;
  color:#7fd6ff;
}
canvas { display:block; }
#hud {
  position:absolute;
  top:14px; left:16px;
  font-size:13px;
  letter-spacing:2px;
  opacity:.75;
}
#status {
  position:absolute;
  top:38px; left:16px;
  font-size:11px;
  opacity:.6;
}
#data {
  position:absolute;
  bottom:16px; left:16px;
  font-size:10px;
  line-height:1.45;
  max-width:420px;
  opacity:.75;
}
#data .real { color:#5dff9c; font-weight:bold; }
#data .fallback { color:#666; }
#data .warning { color:#ffd84d; }
#clock {
  position:absolute;
  bottom:16px; right:16px;
  font-size:11px;
  opacity:.55;
  text-align:right;
}
</style>
</head>
<body>

<div id="hud">GEOMETRIC CHAOS · VECTOR FIELD</div>
<div id="status"></div>
<div id="data">ініціалізація…</div>
<div id="clock">—</div>
<canvas id="c"></canvas>

<script>
/* ===== базова ініціалізація ===== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const dataDiv = document.getElementById('data');
const clockDiv = document.getElementById('clock');
const statusDiv = document.getElementById('status');

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
}
addEventListener('resize', resize);
resize();

/* ===== час ===== */
const startTime = Date.now();
function formatRelative(ms){
  const s = Math.floor(ms/1000);
  if(s<60) return `+${s}s`;
  const m=Math.floor(s/60), ss=s%60;
  if(m<60) return `+${m}m ${ss}s`;
  const h=Math.floor(m/60), mm=m%60;
  return `+${h}h ${mm}m`;
}
setInterval(()=>{
  const n=new Date();
  clockDiv.innerHTML =
    `${String(n.getHours()).padStart(2,'0')}:${String(n.getMinutes()).padStart(2,'0')}:${String(n.getSeconds()).padStart(2,'0')}<br>${formatRelative(Date.now()-startTime)}`;
},1000);

/* ===== дані ===== */
let realData={
  seismic:.5, magnetic:.5,
  atmosphere_wind:.5, atmosphere_pressure:.5,
  atmosphere_temp:.5, ocean:.5,
  solar_radiation:.5, solar_wind:.5,
  precipitation:.5, chaos:.5
};
let history={}; Object.keys(realData).forEach(k=>history[k]=[]);
let sources={};

/* ===== fetch (БЕЗ ЗМІН) ===== */
async function fetchRealPlanetData(){
  statusDiv.innerHTML='оновлення…';
  let loaded=0;
  try{
    const w=await fetch(`https://api.open-meteo.com/v1/forecast?latitude=50.55&longitude=30.25&current=temperature_2m,wind_speed_10m,surface_pressure,precipitation,shortwave_radiation`);
    if(w.ok){
      const c=(await w.json()).current||{};
      realData.atmosphere_temp=Math.min(1,Math.max(0,(c.temperature_2m+40)/80));
      realData.atmosphere_wind=Math.min(1,(c.wind_speed_10m||0)/80);
      realData.atmosphere_pressure=Math.min(1,((c.surface_pressure||1013)-950)/150);
      realData.precipitation=Math.min(1,(c.precipitation||0)/15);
      realData.solar_radiation=Math.min(1,(c.shortwave_radiation||0)/1200);
      loaded+=5;
      sources.atmosphere_temp=sources.atmosphere_wind=sources.atmosphere_pressure=sources.precipitation=sources.solar_radiation=true;
    }
    const eq=await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson');
    if(eq.ok){
      const f=(await eq.json()).features||[];
      const max=f.reduce((m,e)=>Math.max(m,e.properties?.mag||0),0);
      realData.seismic=Math.min(1,(f.length/30)+(max/10)*.5);
      loaded++; sources.seismic=true;
    }
    const proxy='https://corsproxy.io/?';
    try{
      const s=await fetch(proxy+encodeURIComponent('https://services.swpc.noaa.gov/products/geospace/planetary-k-index-1-minute.json'));
      if(s.ok){
        const d=await s.json();
        realData.magnetic=Math.min(1,(parseFloat(d.at(-1)?.[1])||0)/9);
        loaded++; sources.magnetic=true;
      }
    }catch{}
    Object.keys(realData).forEach(k=>{
      if(k!=='chaos'){
        history[k].push(realData[k]);
        if(history[k].length>90) history[k].shift();
      }
    });
    const vars=Object.values(history).map(h=>{
      if(h.length<2) return 0;
      const m=h.reduce((a,b)=>a+b,0)/h.length;
      return Math.sqrt(h.reduce((a,b)=>a+(b-m)**2,0)/h.length);
    });
    realData.chaos=Math.min(1,vars.reduce((a,b)=>a+b,0)/vars.length*10);

    let html='';
    Object.keys(realData).forEach(k=>{
      let cls='fallback';
      if(sources[k]) cls='real';
      else if(k!=='chaos') cls='warning';
      html+=`${k.padEnd(20,' ')} <span class="${cls}">${realData[k].toFixed(3)}</span><br>`;
    });
    dataDiv.innerHTML=html;
    statusDiv.innerHTML=loaded?'оновлено':'';
  }catch(e){ statusDiv.innerHTML=''; }
}
fetchRealPlanetData();
setInterval(fetchRealPlanetData,120000);

/* ===== ГЕОМЕТРИЧНИЙ ФОН · VECTOR FIELD ===== */
let t=0;
function drawGeometry(){
  const w=canvas.width, h=canvas.height;
  const chaos=realData.chaos;

  ctx.fillStyle='rgba(5,7,10,0.25)';
  ctx.fillRect(0,0,w,h);

  const grid=46;
  const sx=w/grid, sy=h/grid;

  ctx.lineWidth=1;
  ctx.strokeStyle=`hsla(${190+chaos*90},80%,55%,${0.15+chaos*0.35})`;

  for(let y=0;y<=grid;y++){
    for(let x=0;x<=grid;x++){
      const px=x*sx, py=y*sy;
      const a=
        Math.sin(x*0.6+t*0.8)+
        Math.cos(y*0.6-t*0.7)+
        chaos*Math.sin((x+y)*0.4);
      const ang=a*Math.PI*0.5;
      const len=10+chaos*40;
      ctx.beginPath();
      ctx.moveTo(px,py);
      ctx.lineTo(px+Math.cos(ang)*len, py+Math.sin(ang)*len);
      ctx.stroke();
    }
  }

  const cx=w/2, cy=h/2;
  for(let r=1;r<=4;r++){
    const sides=6+Math.floor(chaos*10);
    const rad=r*90+Math.sin(t+r)*30;
    ctx.beginPath();
    for(let i=0;i<=sides;i++){
      const ang=i*(Math.PI*2/sides)+t*0.2*r;
      const mod=1+Math.sign(Math.sin(i+t*2))*chaos*0.35;
      const x=cx+Math.cos(ang)*rad*mod;
      const y=cy+Math.sin(ang)*rad*mod;
      i?ctx.lineTo(x,y):ctx.moveTo(x,y);
    }
    ctx.closePath();
    ctx.strokeStyle=`hsla(${160+r*40+chaos*60},70%,${40+r*5}%,${0.18+chaos*0.3})`;
    ctx.lineWidth=1.2+chaos*1.8;
    ctx.stroke();
  }
}

/* ===== лівий графік (БЕЗ ЗМІН) ===== */
function drawGraph(){
  const margin=40, width=200, height=canvas.height-80;
  ctx.strokeStyle='#7fd6ff';
  ctx.beginPath();
  ctx.moveTo(margin,40);
  ctx.lineTo(margin,height+40);
  ctx.lineTo(width+margin,height+40);
  ctx.stroke();

  ctx.font='11px Courier New';
  Object.keys(realData).forEach((k,i)=>{
    const y=40+i*(height/(Object.keys(realData).length-1));
    ctx.fillText(k,6,y+3);
  });

  ctx.strokeStyle='rgba(120,255,190,.8)';
  let prev=null;
  Object.keys(realData).forEach((k,i)=>{
    const x=margin+realData[k]*width;
    const y=40+i*(height/(Object.keys(realData).length-1));
    ctx.beginPath();
    ctx.arc(x,y,4,0,Math.PI*2);
    ctx.fill();
    if(prev){
      ctx.beginPath();
      ctx.moveTo(prev.x,prev.y);
      ctx.lineTo(x,y);
      ctx.stroke();
    }
    prev={x,y};
  });
}

/* ===== цикл ===== */
function loop(){
  t+=0.016;
  drawGeometry();
  drawGraph();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
